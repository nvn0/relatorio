\chapter{Fundamentos teóricos}
\label{chap:theo}

Este capítulo é opcional \textbf{mas altamente recomendado} e, a existir, deve descrever os Fundamentos Teóricos, o que incluirá descrever as tecnologias relevantes, sejam concorrentes ou de fundação.


\section{Linguagens de programação}

fgdh

\subsection{Linguagem C\# (.NET Core)}

O C\# (C Sharp) é uma linguagem de programação desenvolvida pela Microsoft e é amplamente
utilizada para desenvolver aplicações para a plataforma .NET. A versão .NET Core 
é uma implementação de código aberto, multiplataforma e modular do .NET,
que suporta o desenvolvimento de aplicações utilizando C\#.

As principais carecterias do o \textit{framework} .Net Core são:

\begin{itemize}
\item \textbf{Multiplataforma}:  .NET Core é projetado para ser executado em diversas 
plataformas, incluindo Windows, macOS e Linux. Isso permite que os desenvolvedores criem 
aplicações .NET que podem ser executadas nos principais sistemas operativos;
\item \textbf{Código Aberto}: Tanto o .NET Core quanto o C\# são projetos de código
aberto hospedados no GitHub. Isso significa que os desenvolvedores podem contribuir
com melhorias, correções de bugs e novos recursos para a linguagem e framework;
\item \textbf{Desempenho}:  .NET Core foi otimizado para oferecer um melhor desempenho
em comparação com as versões anteriores do .NET Framework. 
Isso inclui melhorias no tempo de inicialização, uso de memória e desempenho de execução;
\item \textbf{Compatibilidade com o Ecossistema .NET}: Embora o .NET Core seja uma 
implementação mais leve e focada do .NET, ele ainda é compatível com grande parte
do ecossistema .NET existente. Isto significa que os desenvolvedores podem aproveitar
bibliotecas e ferramentas existentes ao desenvolver aplicações com .NET Core e C\#;
\item \textbf{Suporte a Tecnologias Modernas}:O .NET Core suporta características 
modernas da linguagem C\#, como \texttt{async/await} para programação assíncrona, padrões de 
programação funcional e muito mais. Isto permite que os pra quem desenvolve aproveite as 
melhores práticas de desenvolvimento de software ao escrever código em C\# para .NET Core.
\end{itemize}


As principais carecterias da linguagem C\# são:


\begin{itemize}
\item \textbf{Tipagem Estática}: C\# é uma linguagem de tipagem estática, o que 
significa que o tipo de cada variável é determinado em tempo de compilação e deve 
ser declarado explicitamente.

\item \textbf{Orientação a Objetos}: C\# é uma linguagem orientada a objetos, 
onde os conceitos de classes e objetos são fundamentais. Tem suporte a heranças, 
encapsulamento, polimorfismo e outras características típicas da programação 
orientada a objetos.

\item \textbf{Sintaxe Simples e Legível}: A sintaxe de C\# é projetada para 
ser fácil de ler e entender. Isto é facilitado pelo uso de palavras-chave intuitivas 
e pela estrutura clara do código.

\item \textbf{Coleta Automática de Lixo (Garbage Collection)}: C\# possui um sistema 
de coleta automática de lixo que faz a gestão da alocação e libertação de memória, 
permitindo que os desenvolvedores se concentrem na lógica do programa sem se preocupar
com bugs relacionados à memória.

\item \textbf{Segurança de Tipo}: C\# é uma linguagem fortemente tipada, o que 
significa que o compilador verifica os tipos em tempo de compilação, ajudando a evitar 
erros comuns relacionados à manipulação de dados.


\item \textbf{Biblioteca Padrão Abrangente}: C\# é acompanhado por uma ampla 
biblioteca padrão, conhecida como .NET \textit{Framework} (ou .NET Core), que oferece
suporte a uma variedade de funcionalidades, como manipulação de ficheiros, acesso a bases 
de dados, desenvolvimento web, entre outros.
\end{itemize}

\subsection{Linguagem Python}


Python é uma linguagem de programação de alto nível, interpretada, dinâmica e 
multiparadigma. Ela foi criada por Guido van Rossum e lançada pela primeira vez em 1991.
Desde então, tornou-se uma das linguagens de programação mais populares do mundo devido
à sua simplicidade, legibilidade e versatilidade.

"Python é uma linguagem de programação de alto nível e propósito geral. A sua filosofia
de design enfatiza a legibilidade do código com o uso de indentação significativa.

Python é dinamicamente tipada e possui coleta de lixo automática. 
Suporta múltiplos paradigmas de programação, incluindo estruturada (particularmente 
procedural), orientada a objetos e programação funcional. É frequentemente descrita como 
uma linguagem "com tudo incluído", devido à sua biblioteca padrão abrangente." \cite{python}



As principais cracteriasaticas desta linguagem são:

\begin{itemize}
\item \textbf{Sintaxe Clara e Concisa}: Python é conhecido pela sua sintaxe limpa
e fácil de ler, o que a torna ideal para iniciantes e facilita a manutenção de código;
\item \textbf{Tipagem Dinâmica}: Em Python, não é necessário declarar explicitamente o
tipo de uma variável. O tipo é inferido dinamicamente durante a execução do programa;
\item \textbf{Multiparadigma}: Python suporta diversos paradigmas de programação,
incluindo programação orientada a objetos, programação imperativa e programação funcional;
\item \textbf{Biblioteca Padrão Abrangente}: Python vem com uma vasta biblioteca 
padrão que oferece suporte para uma ampla gama de tarefas, desde manipulação de arquivos 
até desenvolvimento web;
\item \textbf{Comunidade Ativa}:Python possui uma comunidade
enorme e ativa de desenvolvedores em todo o mundo. Isto resulta numa grande quantidade
de recursos disponíveis, como bibliotecas de terceiros, frameworks e ferramentas 
de desenvolvimento.
\end{itemize}


"Python é suficientemente rápido para o nosso site e permite-nos produzir funcionalidades 
mantíveis em tempos recorde, com um mínimo de programadores." \cite{pyyt}

\section{API}

fdhg

\subsection{O que é uma API?}

fdgh

\section{Unix Socket}

dfgh

\subsection{O que é uma unix socket?}

fghdfhg

\subsection{Como funciona?}

fdhg


\section{Containers}

dfghj

\subsection{Tipos de containers}

fdgh

\subsection{LXD e LXC}

fdghj

\subsection{Incus}

dfhg

\section{FireWalls Linux}

O \textit{kernel} Linux possui desde a versão 2.4, um \textit{framework} de filtragem de pacotes 
conhecido por Netfilter \cite{netfilter}. Este é utilizado utilizado para manipular e inspecionar 
pacotes de rede à medida que entram, saem ou atravessam o sistema.

Porem, a forma mais comum de interagir com o Netfilter é com outras ferramentas,
nomeadamente as duas mais conhecidas, o Iptables e o Nftables.

\subsection{Iptables}

O Iptables é a principal ferramenta associada ao Netfilter, que é uma interface
de linha de comando para configurar regras de filtragem de pacotes.
É posivel definir políticas de segurança, encaminhamento de pacotes,
redirecionamento de portas. 

As funcionalidades do Iptables são organizadas em \textit{tables} ou tabelas
sendo as principais as a \textit{Filter Table}, a \textit{Nat Table} e a
\textit{Mangle Table}, como se pode ver na tabela \ref{ipt1}.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\multicolumn{3}{|c|}{Iptables}\\
\hline
\rowcolor{yellow!50}\textbf{Filter Table} & \textbf{Nat Table} & \textbf{Mangle Table}\\
\hline
INPUT CHAIN & OUTPUT CHAIN & INPUT CHAIN\\
\hline
OUTPUT CHAIN & PREROUTING CHAIN & OUTPUT CHAIN\\
\hline
FORWARD CHAIN & POSTROUTING CHAIN & FORWARD CHAIN\\
\hline
- & - & PREROUTING CHAIN\\
\hline
- & - & POSTROUTING CHAIN\\
\hline
\end{tabular}
\caption{Tabelas principais do Iptables.}
\label{ipt1}
\end{table}


As principais funcionalidades de cada Table são:

\begin{itemize}
\item \textbf{\textit{Filter Table}}: Esta tabela é usada para filtrar pacotes com base em 
políticas de filtragem, como permitir, negar ou descartar pacotes;
\item \textbf{\textit{Nat Table}}: Esta tabela é usada para modificar endereços IP e portas
nos cabeçalhos dos pacotes, principalmente para implementar NAT;
\item \textbf{\textit{Mangle Table}}: Esta tabela é usada para alterar pacotes de maneiras
não abrangidas pelas outras tabelas. Isso pode incluir marcação de pacotes para fins especiais.
\end{itemize}



Existe ainda outras duas tabelas secundarias com propósitos mais simples, dadas 
por \textit{Raw Table} e \textit{Security Table}, como se pode ver na
tabela \ref{ipt2}.


\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\multicolumn{2}{|c|}{Iptables}\\
\hline
\rowcolor{yellow!50}\textbf{Raw Table} & \textbf{Security Table}\\
\hline
OUTPUT CHAIN & INPUT CHAIN \\
\hline
PREROUTING CHAIN & OUTPUT CHAIN \\
\hline
- & FORWARD CHAIN \\
\hline
\end{tabular}
\caption{Tabelas secundárias do Iptables.}
\label{ipt2}
\end{table}
    

\begin{itemize}
\item \textbf{\textit{Raw Table}}: Esta tabela é usada rastrear conexões, com um mecanismo de
marcação de pacotes de modo a mostrar conexões ativas. permite também aplicar
exceções antes que as regras de outras tabelas sejam aplicadas;
\item \textbf{\textit{Security Table}}: Serve para interagir com a ferramenta SELinux, marcando
os pacotes para depois serem interpretados pela ferramenta de segurança.
\end{itemize}


% \title*{\textbf{Chains}}

No Iptables uma \textit{table} é um conjunto de \textit{chains} em que cada Chain tem uma função
especifica. As \textit{Chains} mais comuns são:

\begin{itemize}
\item \textbf{\textit{INPUT}}: Aplicada a pacotes destinados ao próprio sistema;
\item \textbf{\textit{OUTPUT}}: Aplicada a pacotes gerados pelo próprio sistema;
\item \textbf{\textit{FORWARD}}: Aplicada a pacotes que são reencaminhados pelo sistema,
ou seja, não são originados ou destinados ao próprio sistema, mas estão apenas a passar
por ele;
\item \textbf{\textit{PREROUTING}}:Esta \textit{chain} é acionada antes que o kernel 
aplique qualquer roteamento ao pacote recebido. Isto significa que, quando um pacote 
chega ao sistema, mas antes que o kernel determine qual interface de rede que deve ser 
usada para encaminhar o pacote para o destino final;
\item \textbf{\textit{POSTROUTING}}: Esta cadeia é acionada após o roteamento 
ter sido determinado, mas antes de o pacote ser enviado pela interface de rede.
Isto significa que, uma vez que o kernel tenha decidido qual a interface de rede que
deve ser usada para enviar o pacote, este passará por esta \textit{chain} para fazer 
quaisquer ajustes finais antes que o pacote deixe o sistema.
\end{itemize}

% \title*{\textbf{Regras}}

O Iptables funciona de forma sequencial, ou seja, quando uma regra é colocada
numa \textit{chain} essa regra tem um numero ou posição. Desta forma, quando um 
pacote está a ser processado por uma \textit{chain} são verificadas as regras 
dessa \textit{chain} desde a primeira até à última, até que uma corresponda a
parametros do pacote e portanto, seja ativada.

Numa regra é possivel especificar parametros como a interface de entrada, 
a interface de saída, IP de destino, IP de origem,o protocolo, a porta de 
origem, porta de destino e ação a tomar na regra (aceitar, rejeitar, descartar).

A seguite tabela \ref{ipt3args} mostra uma lista mais completa de parametros a usar na
criação de regras do IPTables:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\multicolumn{2}{|c|}{Parametros}\\
\hline
\textbf{Prametro} & \textbf{sintaxe} \\
\hline
table & -t nome da table \\
\hline
posição da regra na chain & \textbf{-I} para o topo e \textbf{-A} para o fundo da lista \\
\hline
Chain & INPUT, OUTPUT, FORWARD, PREROUTING, POSTROUTING \\
\hline
protocolo & \textbf{-p} nome do protocolo  \\
\hline
ip de origem & \textbf{-s} endereço IP  \\
\hline
ip de destino & \textbf{-d} endereço IP  \\
\hline
porta de origem & \textbf{--sport} porta  \\
\hline
porta de destino & \textbf{--dport} porta  \\
\hline
ação & \textbf{-j} ACCEPT/REJECT/DROP  \\
\hline
\end{tabular}
\caption{Parametros possiveis na criação de regras.}
\label{ipt3args}
\end{table}
    
Segue agora um exemplo de uma regra para a tabela \textit{Filter} na 
\textit{INPUT Chain} para negar o tráfego de entrada para a porta 22:

\begin{lstlisting}[language=Bash, caption={exemplo de comando}]
iptabels -I INPUT -p tcp --dport 22 -j DROP
\end{lstlisting}

\textbf{Nota}: Não é necessário especificar no comando a tabela  com o parametro
\textbf{-t} quando se quer adicionar uma regra na \textit{Filter Table}.

\subsection{Nftables}

O Nftables \cite{nftables} concebido para ser o sucessor do Iptables e disponivel para sistemas 
Linux apartir da versão 3.13 do \textit{kernel}.

"Este software fornece uma nova estrutura de classificação de pacotes no kernel 
que é baseada em uma máquina virtual (VM) específica da rede e uma nova ferramenta 
de linha de comando do espaço do utilizador nft. nftables reutiliza os subsistemas 
existentes do Netfilter, como a infraestrutura de gancho existente, o sistema de 
rastreamento de conexão, NAT, enfileiramento do espaço do usuário e subsistema de 
registro" \cite{nftables}.

A sintaxe do Nftables difere da do Iptables, porém existe uma camada de 
compatibilidade que permite usar o Iptables sobre a infraestrutura do Nftables.


Algumas das principais diferenças entre nftables e iptables do ponto de vista do 
utilizador são \cite{diffiptenft}:

\begin{enumerate}

\item " \textbf{Sintaxe nova}: nftables utiliza uma nova sintaxe. A ferramenta de 
linha de comandos iptables usa um \textit{parser} baseado em \textit{getoptlong()}, onde as 
chaves são sempre precedidas por dois hífens, por exemplo, \texttt{--chave} ou 
um único hífen, por exemplo, \texttt{-p tcp}. Em contraste, nftables usa uma 
sintaxe compacta inspirada no tcpdump.

\item \textbf{Tabelas e cadeias totalmente configuráveis}: iptables tem várias 
tabelas pré-definidas e cadeias base, todas registadas mesmo que só precise de uma 
delas. Houve relatos de que até cadeias base não utilizadas prejudicam o desempenho. 
Com nftables não existem tabelas ou cadeias pré-definidas. Cada tabela é explicitamente 
definida e contém apenas os objetos (cadeias, conjuntos, mapas, tabelas de fluxo e 
objetos stateful) que você adiciona explicitamente a ela. Agora regista apenas as 
cadeias base de que precisa. Escolhe nomes de tabela e de cadeia e prioridades de 
gancho netfilter que implementem eficientemente a pipeline de processamento de 
pacotes específico.

\item \textbf{Uma única regra nftables pode ter várias ações}: Em vez dos correspondentes 
e ações de destino únicos utilizados em iptables, uma regra nftables consiste em zero 
ou mais expressões seguidas de uma ou mais declarações. Cada expressão testa se um pacote 
corresponde a um campo de carga útil específico ou a metadados do pacote/fluxo. Múltiplas 
expressões são avaliadas linearmente da esquerda para a direita: se a primeira expressão 
corresponder, então a próxima expressão é avaliada e assim por diante. Se chegarmos à 
expressão final, então o pacote corresponde a todas as expressões na regra, e as 
declarações da regra são executadas. Cada declaração toma uma ação, como definir 
a marca netfilter, contar o pacote, registar o pacote ou renderizar um veredito 
como aceitar ou descartar o pacote ou saltar para outra cadeia. Tal como com as 
expressões, múltiplas declarações são avaliadas linearmente da esquerda para a 
direita: uma única regra pode ter várias ações utilizando múltiplas declarações. 
Note que uma declaração de veredito por sua natureza termina a regra.

\item \textbf{Sem contador incorporado por cadeia e regra}: Em nftables, os contadores 
são opcionais, pode ativá-los conforme necessário.

\item \textbf{Melhor suporte para atualizações dinâmicas do conjunto de regras}: Em 
contraste com o monólito utilizado por iptables, os conjuntos de regras nftables são 
representados internamente numa lista encadeada. Agora, adicionar ou remover uma regra 
deixa o resto do conjunto de regras intocado, simplificando a manutenção da informação 
de estado interna.

\item \textbf{Administração dual stack IPv4/IPv6 simplificada}: A família inet de 
nftables permite-lhe registar cadeias base que veem tanto o tráfego IPv4 como IPv6. 
Já não é necessário depender de scripts para duplicar o seu conjunto de regras.

\item \textbf{Nova infraestrutura de conjunto genérico}: Esta infraestrutura integra-se 
estreitamente no núcleo nftables e permite configurações avançadas como mapas, mapas 
de veredito e intervalos para alcançar a classificação de pacotes orientada ao desempenho. O mais importante é que pode utilizar qualquer seletor suportado para classificar o tráfego.

\item \textbf{Suporte para concatenações}: Desde o kernel Linux 4.1, pode concatenar 
vários chaves e combiná-las com mapas e mapas de veredito. A ideia é construir uma tupla 
cujos valores são hash para obter a ação a ser executada quase O(1).

\item \textbf{Suporta novos protocolos sem atualização do kernel}: As atualizações do 
kernel podem ser demoradas e intimidantes, especialmente se tiver que manter mais do 
que um firewall na sua rede. Os kernels de distribuição geralmente ficam atrás da 
versão mais recente. Com a nova abordagem de máquina virtual nftables, suportar 
um novo protocolo frequentemente não requer um novo kernel, apenas uma atualização 
relativamente simples do software de espaço de utilizador nft."
\end{enumerate}


\section*{Sumário}

dsfg

Ver o \nameref{sec:intro_summary} na página \pageref{sec:intro_summary} para perceber como utilizar esta secção.
