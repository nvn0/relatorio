\chapter{Fundamentos teóricos}
\label{chap:theo}

Este capítulo é opcional \textbf{mas altamente recomendado} e, a existir, deve descrever os Fundamentos Teóricos, o que incluirá descrever as tecnologias relevantes, sejam concorrentes ou de fundação.

Neste capitulo serão abordadas tecnologias e fundamentos teóricos relevantes para 
este projeto. \\

\section{Distribuições Linux}

Sendo Linux apenas um \textit{Kernel}, ou seja, um "nucleo" de um sistema operativo
o mesmo não pode ser usado si só da mesma forma que outros sistemas operativos.
Para ter um sistema completo é necessário adicionar multiplos programas/bibliotecas,
sendo assim, existe um numero elevado de sistemas operativos basedos em Linux.

Certas distribuições podem ter diferentes alvos de utilizadores/utilização, quer seja,
para uso pessoal/tradicional de um utilizar comum, quer seja para servidores.

As principais vantagens associadas ao uso de um Sistema operativo baseado em Linux são:
\begin{enumerate}
    \item Não é preciso licensa de utilização;
    \item Código aberto;
    \item É um sistema que por norma consome menos recursos que a maioria das distribuições disponiveis;
    \item costumização.
\end{enumerate} 



\section{Alpine Linux}

"Alpine Linux é uma distribuição Linux baseada em musl e BusyBox originalmente
projetada para utilizadores avançados que apreciam segurança, simplicidade e eficiência 
no uso de recursos." \cite{alpinewiki}

O Alpine Linux é uma distribuição independente, isto é, não baseda em nunhuma 
outra distribuição como muitas outras. E usada principalmente em ambientes
profissionais/servidores.

Esta distribuição é projetada para ser extremamente leve, com uma instalação 
mínima que ocupa apenas alguns megabytes de espaço. \\

\subsection{Segurança do sistema}

É também focada em ser um sistema 
seguro daí incorporar  medidas como o \textit{Position Independent Executables} (PIE) e 
o \textit{Stack Smashing Protection} (SSP) por padrão.

O \textit{Position Independent Executables} (PIE) são um tipo de executável que pode ser 
carregado em qualquer endereço da memória, ao contrário de executáveis tradicionais 
que são carregados para um endereço fixo. Isto aumenta a segurança do sistema uma vez que
o PIE usa o ASLR (\textit{Address space layout randomization}) para criar aleatoriedade
nas posições de áreas-chave de memória, como a \textit{stack}, o heap e as bibliotecas compartilhadas.

Desta forma com os executáveis sendo carregados em diferentes endereços em cada execução, 
é muito mais difícil para os atacantes desenvolverem explorações confiáveis que funcionem 
em todas as execuções.


O \textit{Stack Smashing Protection} (SSP) é uma técnica de segurança usada para detectar e
prevenir ataques de \textit{buffer overflow}. Este método consiste no SSP introduzir um valor 
especial conhecido como "\textit{canary}" entre a \textit{stack} de variáveis locais e o endereço de 
retorno da função. Antes de uma função retornar, o valor do "\textit{canary}" é verificado.
Se o "\textit{canary}" tiver sido alterado (indicando assim que a \textit{stack} foi corrompida), 
o programa é abortado. 

Para garantir estas técnicas de segurança no sistema, todos os pacotes no Alpine Linux
são compilados com suporte a PIE, garantindo que todos os executáveis possam se 
beneficiar da ASLR.

O compilador tem que ser também configurado para incluir proteção SSP por padrão,
adicionando "\textit{canarys}" de \textit{stack} aos binários compilados para detectar 
e mitigar \textit{buffer overflows}.



\subsection{Diferenças entre o Alpine Linux em relação a outras distribuições}

Principais diferenças do Alpine Linux com a maioria das distribuições Linux disponiveis são:
\begin{itemize}
    \item O seu \textit{init system} é o OpenRC;
    \item A \textit{shell} predefenida é o busybox ao contrário do famoso \textit{Bash} ou ZSH;
    \item Gestor de pagotes é o "\texttt{apk} (\textit{Alpine Package Keeper})";
    \item Por padrão, para executar comandos de forma administrativa é ncessário usar do comados "\texttt{doas}" em vez do "\texttt{sudo}".
\end{itemize} 

\subsection{Conlusão}

Em suma, o Alpine Linux é uma excelente escolha quando o objetivo é ter um sistema 
leve, seguro e eficiente, especialmente adequado para ambientes de servidores, containers
e sistemas embutidos.


\section{Linguagens de programação}

Nesta secção serão abordadas liguagens de programação relevantes no projeto.

\subsection{Linguagem C\# (.NET Core)}

O C\# (C Sharp) é uma linguagem de programação desenvolvida pela Microsoft e é amplamente
utilizada para desenvolver aplicações para a plataforma .NET. A versão .NET Core 
é uma implementação de código aberto, multiplataforma e modular do .NET,
que suporta o desenvolvimento de aplicações utilizando C\#.

As principais carecterias do o \textit{framework} .Net Core são:

\begin{itemize}
\item \textbf{Multiplataforma}:  .NET Core é projetado para ser executado em diversas 
plataformas, incluindo Windows, macOS e Linux. Isso permite que os desenvolvedores criem 
aplicações .NET que podem ser executadas nos principais sistemas operativos;
\item \textbf{Código Aberto}: Tanto o .NET Core quanto o C\# são projetos de código
aberto hospedados no GitHub. Isso significa que os desenvolvedores podem contribuir
com melhorias, correções de bugs e novos recursos para a linguagem e framework;
\item \textbf{Desempenho}:  .NET Core foi otimizado para oferecer um melhor desempenho
em comparação com as versões anteriores do .NET Framework. 
Isso inclui melhorias no tempo de inicialização, uso de memória e desempenho de execução;
\item \textbf{Compatibilidade com o Ecossistema .NET}: Embora o .NET Core seja uma 
implementação mais leve e focada do .NET, ele ainda é compatível com grande parte
do ecossistema .NET existente. Isto significa que os desenvolvedores podem aproveitar
bibliotecas e ferramentas existentes ao desenvolver aplicações com .NET Core e C\#;
\item \textbf{Suporte a Tecnologias Modernas}:O .NET Core suporta características 
modernas da linguagem C\#, como \texttt{async/await} para programação assíncrona, padrões de 
programação funcional e muito mais. Isto permite que os pra quem desenvolve aproveite as 
melhores práticas de desenvolvimento de software ao escrever código em C\# para .NET Core.
\end{itemize}


As principais carecterias da linguagem C\# são:


\begin{itemize}
\item \textbf{Tipagem Estática}: C\# é uma linguagem de tipagem estática, o que 
significa que o tipo de cada variável é determinado em tempo de compilação e deve 
ser declarado explicitamente;

\item \textbf{Orientação a Objetos}: C\# é uma linguagem orientada a objetos, 
onde os conceitos de classes e objetos são fundamentais. Tem suporte a heranças, 
encapsulamento, polimorfismo e outras características típicas da programação 
orientada a objetos;

\item \textbf{Sintaxe Simples e Legível}: A sintaxe de C\# é projetada para 
ser fácil de ler e entender. Isto é facilitado pelo uso de palavras-chave intuitivas 
e pela estrutura clara do código;

\item \textbf{Coleta Automática de Lixo (Garbage Collection)}: C\# possui um sistema 
de coleta automática de lixo que faz a gestão da alocação e libertação de memória, 
permitindo que os desenvolvedores se concentrem na lógica do programa sem se preocupar
com bugs relacionados à memória;

\item \textbf{Segurança de Tipo}: C\# é uma linguagem fortemente tipada, o que 
significa que o compilador verifica os tipos em tempo de compilação, ajudando a evitar 
erros comuns relacionados à manipulação de dados;


\item \textbf{Biblioteca Padrão Abrangente}: C\# é acompanhado por uma ampla 
biblioteca padrão, conhecida como .NET \textit{Framework} (ou .NET Core), que oferece
suporte a uma variedade de funcionalidades, como manipulação de ficheiros, acesso a bases 
de dados, desenvolvimento web, entre outros.
\end{itemize}



\subsection{Linguagem Python}


Python é uma linguagem de programação de alto nível, interpretada, dinâmica e 
multiparadigma. Ela foi criada por Guido van Rossum e lançada pela primeira vez em 1991.
Desde então, tornou-se uma das linguagens de programação mais populares do mundo devido
à sua simplicidade, legibilidade e versatilidade.

"Python é uma linguagem de programação de alto nível e propósito geral. A sua filosofia
de design enfatiza a legibilidade do código com o uso de indentação significativa.

Python é dinamicamente tipada e possui coleta de lixo automática. 
Suporta múltiplos paradigmas de programação, incluindo estruturada (particularmente 
procedural), orientada a objetos e programação funcional. É frequentemente descrita como 
uma linguagem "com tudo incluído", devido à sua biblioteca padrão abrangente." \cite{python}



As principais cracteriasaticas desta linguagem são:

\begin{itemize}
\item \textbf{Sintaxe Clara e Concisa}: Python é conhecido pela sua sintaxe limpa
e fácil de ler, o que a torna ideal para iniciantes e facilita a manutenção de código;
\item \textbf{Tipagem Dinâmica}: Em Python, não é necessário declarar explicitamente o
tipo de uma variável. O tipo é inferido dinamicamente durante a execução do programa;
\item \textbf{Multiparadigma}: Python suporta diversos paradigmas de programação,
incluindo programação orientada a objetos, programação imperativa e programação funcional;
\item \textbf{Biblioteca Padrão Abrangente}: Python vem com uma vasta biblioteca 
padrão que oferece suporte para uma ampla gama de tarefas, desde manipulação de arquivos 
até desenvolvimento web;
\item \textbf{Comunidade Ativa}:Python possui uma comunidade enorme e ativa de 
desenvolvedores em todo o mundo. Isto resulta numa grande quantidade
de recursos disponíveis, como bibliotecas de terceiros, frameworks e ferramentas 
de desenvolvimento.
\end{itemize}


"Python é suficientemente rápido para o nosso site e permite-nos produzir funcionalidades 
mantíveis em tempos recorde, com um mínimo de programadores." \cite{pyyt}


\section{Bibliotecas/FrameWorks relevantes para o projeto}

dfgs

\subsection{Flask (Python)}


dfgs

\section{APIs}

Nesta secção serão explicadas as APIs e como esta funcionam.


\subsection{O que é uma API?}

Uma API (Application Programming Interface) é uma interface que permite a interação entre diferentes componentes de software. 
Ela define métodos e protocolos de comunicação para que desenvolvedores possam utilizar 
funcionalidades específicas sem precisar entender os detalhes internos da implementação.
O serviço ao qual uma API pode estar associada pode ser um sistema operativo, uma biblioteca
de \textit{software} ou um serviço \textit{web}.

Alguns exemplos de APIs são a API do sistema de ficheiros do Node.js o "fs" e o DirectX 
da Microsoft, usada para tarefas relacionadas com multimídia e gráficos.

\subsection{O que é uma REST API?}


"A REST API (also called a RESTful API or RESTful web API) is an application 
programming interface (API) that conforms to the design principles of the representational
state transfer (REST) architectural style. REST APIs provide a flexible, lightweight way 
to integrate applications and to connect components in microservices architectures." \cite{ibmrestapi}



Uma REST API é um tipo de API que adere aos princípios do REST que é uma arquitetura
de \textit{software} orientada a serviços \textit{WEB}.
A lógica deste de funcionamento consiste em computadores enviarem recursos textuais através
de solicitações \textit{HTTP} pela \textit{internet} para um URL específico. \\

Alguns exemplos de REST APIs são a API do Discord que permite um utilizador mandar mensagens fora
da aplicação de cliente, usando apenas solicitações \textit{HTTP}, outra plataforma é 
o X (antigo Twitter) fazer "tweets" da mesma forma.


As solicitações \textit{HTTP} possuí as seguintes operações:
\begin{itemize}
    \item GET - Usado para solicitar dados de um recurso específico;
    \item HEAD - Similar ao GET, mas só retorna os cabeçalhos da resposta sem o corpo;
    \item POST - Enviar dados ao servidor para criar um novo recurso; 
    \item PUT - Atualizar um recurso específico com dados novos;
    \item PATCH - Atualizar parcialmente um recurso existente; 
    \item DELETE - Usado para apagar um recurso específico; 
    \item CONNECT - Principalmente usado para iniciar uma comunicação
    segura (via SSL/TLS) com um servidor proxy; 
    \item OPTIONS - Usado para descobrir os métodos suportados pelo servidor para um recurso específico;
    \item TRACE - Usado para depurar e rastrear o caminho que uma solicitação HTTP percorre.
\end{itemize}


Os principais formatos de texto a serem enviados nas solicitações são:
\begin{itemize}
    \item HTML;
    \item JSON;
    \item XML.
\end{itemize}


\section{Unix Socket}

Uma Unix Socket, também conhecida como Unix Domain Socket, 
é um mecanismo de comunicação interprocessual  que permite a troca de dados 
entre processos executados no mesmo sistema operativo.

Unix Sockets são frequentemente utilizados em sistemas Unix e Unix-like
(como Linux e macOS) para proporcionar uma comunicação eficiente e de baixa 
latência entre processos.


\subsection{Como funciona?}

Diferente das sockets de rede (TCP/IP), as Unix Sockets são usadas para 
comunicação local entre processos no mesmo sistema. Estas não dependem de interfaces 
de rede ou protocolos de rede.

Em vez de usar endereços IP e números de porta, as Unix Sockets utilizam caminhos 
no sistema de ficheiros (ex.: /tmp/socketfile).

\section{Containers}

\textit{Containers} são uma tecnologia de virtualização a nível de sistema operativo que 
permite executar várias aplicações ou sistemas operativos isolados em um único \textit{host}, usando o mesmo kernel. 
Fornecem ainda um ambiente leve, portátil e eficiente para empacotar e executar aplicações,
oferecendo isolamento semelhante ao das máquinas virtuais, mas com a uma menor
exigência de recursos.

Alguns exemplos de getores de \textit{containers} disponiveis atualmente:
\begin{itemize}
    \item Docker;
    \item LXD/LXC;
    \item rkt (Rocket);
    \item CRI-O;
    \item Podman.
\end{itemize}



\subsection{LXD e LXC}

LXD e LXC serão a principal tecnologia de \textit{containers} abordada neste projeto,
uma vez que é a mesma usada na plataforma Forge do IPMAIA/UMAIA. \\



\title*{\textbf{LXC (Linux Containers)}}

LXC é uma tecnologia de \textit{contaianers}, inicialmente desenvolvido pela IBM, 
de baixo nível que fornece containers leves e isolados usando namespaces e cgroups 
do kernel do Linux. \\

\begin{itemize}
    \item Namespaces: Proporcionam isolamento para processos, IDs de utilizadores, 
    sistema de ficheiros, redes, IPC (Inter-Process Communication), etc.;
    \item Cgroups: Gerem e limitam os recursos (CPU, memória, I/O) que um
    \textit{container} pode usar.
\end{itemize}

\title*{\textbf{LXD}}

Patrocinado pela Canonical Ltd. desde a sua  criação, LXD é uma camada de gestão para LXC, 
que oferece uma experiência de utilização mais amigável e recursos avançados.

As principais vantagens associadas ao LXD são:
\begin{itemize}
\item Interface de Linha de Comando (CLI): Comando "lxc" para gerir \textit{containers}
de maneira intuitiva;
\item API REST: Fornece uma API RESTful através de unix sockets ou solicitações HTTP para automação e integração com outras ferramentas.
\item \textit{Snapshots} e \textit{Backups}: Suporte para \textit{snapshots} e \textit{backups} dos \textit{containers}.
\item \textit{Live Migration}: Permite a migração ao vivo de \textit{containers} entre \textit{hosts}.
\item Uso de {Clusters}: Possibilidade de criar clusters de múltiplos hosts para gestão centralizada de \textit{containers}.
\end{itemize}


\subsection{Incus}

Incus é a próxima geração de gestão para LXC, com o princiapl objetivo de substituiur
O LXD.

\section{FireWalls Linux}

O \textit{kernel} Linux possui desde a versão 2.4, um \textit{framework} de filtragem de pacotes 
conhecido por Netfilter \cite{netfilter}. Este é utilizado utilizado para manipular e inspecionar 
pacotes de rede à medida que entram, saem ou atravessam o sistema.

Porem, a forma mais comum de interagir com o Netfilter é com outras ferramentas,
nomeadamente as duas mais conhecidas, o Iptables e o Nftables.

\subsection{Iptables}

O Iptables é a principal ferramenta associada ao Netfilter, que é uma interface
de linha de comando para configurar regras de filtragem de pacotes.
É posivel definir políticas de segurança, encaminhamento de pacotes,
redirecionamento de portas. 

As funcionalidades do Iptables são organizadas em \textit{tables} ou tabelas
sendo as principais as a \textit{Filter Table}, a \textit{Nat Table} e a
\textit{Mangle Table}, como se pode ver na tabela \ref{ipt1}.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
\hline
\multicolumn{3}{|c|}{Iptables}\\
\hline
\rowcolor{yellow!50}\textbf{Filter Table} & \textbf{Nat Table} & \textbf{Mangle Table}\\
\hline
INPUT CHAIN & OUTPUT CHAIN & INPUT CHAIN\\
\hline
OUTPUT CHAIN & PREROUTING CHAIN & OUTPUT CHAIN\\
\hline
FORWARD CHAIN & POSTROUTING CHAIN & FORWARD CHAIN\\
\hline
- & - & PREROUTING CHAIN\\
\hline
- & - & POSTROUTING CHAIN\\
\hline
\end{tabular}
\caption{Tabelas principais do Iptables.}
\label{ipt1}
\end{table}


As principais funcionalidades de cada Table são:

\begin{itemize}
\item \textbf{\textit{Filter Table}}: Esta tabela é usada para filtrar pacotes com base em 
políticas de filtragem, como permitir, negar ou descartar pacotes;
\item \textbf{\textit{Nat Table}}: Esta tabela é usada para modificar endereços IP e portas
nos cabeçalhos dos pacotes, principalmente para implementar NAT;
\item \textbf{\textit{Mangle Table}}: Esta tabela é usada para alterar pacotes de maneiras
não abrangidas pelas outras tabelas. Isso pode incluir marcação de pacotes para fins especiais.
\end{itemize}



Existe ainda outras duas tabelas secundarias com propósitos mais simples, dadas 
por \textit{Raw Table} e \textit{Security Table}, como se pode ver na
tabela \ref{ipt2}.


\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\multicolumn{2}{|c|}{Iptables}\\
\hline
\rowcolor{yellow!50}\textbf{Raw Table} & \textbf{Security Table}\\
\hline
OUTPUT CHAIN & INPUT CHAIN \\
\hline
PREROUTING CHAIN & OUTPUT CHAIN \\
\hline
- & FORWARD CHAIN \\
\hline
\end{tabular}
\caption{Tabelas secundárias do Iptables.}
\label{ipt2}
\end{table}
    

\begin{itemize}
\item \textbf{\textit{Raw Table}}: Esta tabela é usada rastrear conexões, com um mecanismo de
marcação de pacotes de modo a mostrar conexões ativas. permite também aplicar
exceções antes que as regras de outras tabelas sejam aplicadas;
\item \textbf{\textit{Security Table}}: Serve para interagir com a ferramenta SELinux, marcando
os pacotes para depois serem interpretados pela ferramenta de segurança.
\end{itemize}


% \title*{\textbf{Chains}}

No Iptables uma \textit{table} é um conjunto de \textit{chains} em que cada Chain tem uma função
especifica. As \textit{Chains} mais comuns são:

\begin{itemize}
\item \textbf{\textit{INPUT}}: Aplicada a pacotes destinados ao próprio sistema;
\item \textbf{\textit{OUTPUT}}: Aplicada a pacotes gerados pelo próprio sistema;
\item \textbf{\textit{FORWARD}}: Aplicada a pacotes que são reencaminhados pelo sistema,
ou seja, não são originados ou destinados ao próprio sistema, mas estão apenas a passar
por ele;
\item \textbf{\textit{PREROUTING}}:Esta \textit{chain} é acionada antes que o kernel 
aplique qualquer roteamento ao pacote recebido. Isto significa que, quando um pacote 
chega ao sistema, mas antes que o kernel determine qual interface de rede que deve ser 
usada para encaminhar o pacote para o destino final;
\item \textbf{\textit{POSTROUTING}}: Esta cadeia é acionada após o roteamento 
ter sido determinado, mas antes de o pacote ser enviado pela interface de rede.
Isto significa que, uma vez que o kernel tenha decidido qual a interface de rede que
deve ser usada para enviar o pacote, este passará por esta \textit{chain} para fazer 
quaisquer ajustes finais antes que o pacote deixe o sistema.
\end{itemize}

% \title*{\textbf{Regras}}

O Iptables funciona de forma sequencial, ou seja, quando uma regra é colocada
numa \textit{chain} essa regra tem um numero ou posição. Desta forma, quando um 
pacote está a ser processado por uma \textit{chain} são verificadas as regras 
dessa \textit{chain} desde a primeira até à última, até que uma corresponda a
parametros do pacote e portanto, seja ativada.

Numa regra é possivel especificar parametros como a interface de entrada, 
a interface de saída, IP de destino, IP de origem,o protocolo, a porta de 
origem, porta de destino e ação a tomar na regra (aceitar, rejeitar, descartar).

A seguite tabela \ref{ipt3args} mostra uma lista mais completa de parametros a usar na
criação de regras do IPTables:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\multicolumn{2}{|c|}{Parametros}\\
\hline
\textbf{Prametro} & \textbf{sintaxe} \\
\hline
table & -t nome da table \\
\hline
posição da regra na chain & \textbf{-I} para o topo e \textbf{-A} para o fundo da lista \\
\hline
Chain & INPUT, OUTPUT, FORWARD, PREROUTING, POSTROUTING \\
\hline
protocolo & \textbf{-p} nome do protocolo  \\
\hline
ip de origem & \textbf{-s} endereço IP  \\
\hline
ip de destino & \textbf{-d} endereço IP  \\
\hline
porta de origem & \textbf{--sport} porta  \\
\hline
porta de destino & \textbf{--dport} porta  \\
\hline
ação & \textbf{-j} ACCEPT/REJECT/DROP  \\
\hline
\end{tabular}
\caption{Parametros possiveis na criação de regras.}
\label{ipt3args}
\end{table}
    
Segue agora um exemplo de uma regra para a tabela \textit{Filter} na 
\textit{INPUT Chain} para negar o tráfego de entrada para a porta 22:

\begin{lstlisting}[language=Bash, caption={exemplo de comando}]
iptabels -I INPUT -p tcp --dport 22 -j DROP
\end{lstlisting}

\textbf{Nota}: Não é necessário especificar no comando a tabela  com o parametro
\textbf{-t} quando se quer adicionar uma regra na \textit{Filter Table}.

\subsection{Nftables}

O Nftables \cite{nftables} concebido para ser o sucessor do Iptables e disponivel para sistemas 
Linux apartir da versão 3.13 do \textit{kernel}.

"Este software fornece uma nova estrutura de classificação de pacotes no kernel 
que é baseada em uma máquina virtual (VM) específica da rede e uma nova ferramenta 
de linha de comando do espaço do utilizador nft. nftables reutiliza os subsistemas 
existentes do Netfilter, como a infraestrutura de gancho existente, o sistema de 
rastreamento de conexão, NAT, enfileiramento do espaço do usuário e subsistema de 
registro" \cite{nftables}.

A sintaxe do Nftables difere da do Iptables, porém existe uma camada de 
compatibilidade que permite usar o Iptables sobre a infraestrutura do Nftables.


Algumas das principais diferenças entre nftables e iptables do ponto de vista do 
utilizador são \cite{diffiptenft}:

\begin{enumerate}

\item " \textbf{Sintaxe nova}: nftables utiliza uma nova sintaxe. A ferramenta de 
linha de comandos iptables usa um \textit{parser} baseado em \textit{getoptlong()}, onde as 
chaves são sempre precedidas por dois hífens, por exemplo, \texttt{--chave} ou 
um único hífen, por exemplo, \texttt{-p tcp}. Em contraste, nftables usa uma 
sintaxe compacta inspirada no tcpdump.

\item \textbf{Tabelas e cadeias totalmente configuráveis}: iptables tem várias 
tabelas pré-definidas e cadeias base, todas registadas mesmo que só precise de uma 
delas. Houve relatos de que até cadeias base não utilizadas prejudicam o desempenho. 
Com nftables não existem tabelas ou cadeias pré-definidas. Cada tabela é explicitamente 
definida e contém apenas os objetos (cadeias, conjuntos, mapas, tabelas de fluxo e 
objetos stateful) que você adiciona explicitamente a ela. Agora regista apenas as 
cadeias base de que precisa. Escolhe nomes de tabela e de cadeia e prioridades de 
gancho netfilter que implementem eficientemente a pipeline de processamento de 
pacotes específico.

\item \textbf{Uma única regra nftables pode ter várias ações}: Em vez dos correspondentes 
e ações de destino únicos utilizados em iptables, uma regra nftables consiste em zero 
ou mais expressões seguidas de uma ou mais declarações. Cada expressão testa se um pacote 
corresponde a um campo de carga útil específico ou a metadados do pacote/fluxo. Múltiplas 
expressões são avaliadas linearmente da esquerda para a direita: se a primeira expressão 
corresponder, então a próxima expressão é avaliada e assim por diante. Se chegarmos à 
expressão final, então o pacote corresponde a todas as expressões na regra, e as 
declarações da regra são executadas. Cada declaração toma uma ação, como definir 
a marca netfilter, contar o pacote, registar o pacote ou renderizar um veredito 
como aceitar ou descartar o pacote ou saltar para outra cadeia. Tal como com as 
expressões, múltiplas declarações são avaliadas linearmente da esquerda para a 
direita: uma única regra pode ter várias ações utilizando múltiplas declarações. 
Note que uma declaração de veredito por sua natureza termina a regra.

\item \textbf{Sem contador incorporado por cadeia e regra}: Em nftables, os contadores 
são opcionais, pode ativá-los conforme necessário.

\item \textbf{Melhor suporte para atualizações dinâmicas do conjunto de regras}: Em 
contraste com o monólito utilizado por iptables, os conjuntos de regras nftables são 
representados internamente numa lista encadeada. Agora, adicionar ou remover uma regra 
deixa o resto do conjunto de regras intocado, simplificando a manutenção da informação 
de estado interna.

\item \textbf{Administração dual stack IPv4/IPv6 simplificada}: A família inet de 
nftables permite-lhe registar cadeias base que veem tanto o tráfego IPv4 como IPv6. 
Já não é necessário depender de scripts para duplicar o seu conjunto de regras.

\item \textbf{Nova infraestrutura de conjunto genérico}: Esta infraestrutura integra-se 
estreitamente no núcleo nftables e permite configurações avançadas como mapas, mapas 
de veredito e intervalos para alcançar a classificação de pacotes orientada ao desempenho. O mais importante é que pode utilizar qualquer seletor suportado para classificar o tráfego.

\item \textbf{Suporte para concatenações}: Desde o kernel Linux 4.1, pode concatenar 
vários chaves e combiná-las com mapas e mapas de veredito. A ideia é construir uma tupla 
cujos valores são hash para obter a ação a ser executada quase O(1).

\item \textbf{Suporta novos protocolos sem atualização do kernel}: As atualizações do 
kernel podem ser demoradas e intimidantes, especialmente se tiver que manter mais do 
que um firewall na sua rede. Os kernels de distribuição geralmente ficam atrás da 
versão mais recente. Com a nova abordagem de máquina virtual nftables, suportar 
um novo protocolo frequentemente não requer um novo kernel, apenas uma atualização 
relativamente simples do software de espaço de utilizador nft."
\end{enumerate}


\section*{Sumário}

dsfg

Ver o \nameref{sec:intro_summary} na página \pageref{sec:intro_summary} para perceber como utilizar esta secção.
